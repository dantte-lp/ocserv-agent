name: CI

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'LICENSE'
      - '.gitignore'
      - 'docs/**'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'LICENSE'
      - '.gitignore'
      - 'docs/**'

permissions:
  contents: read

jobs:
  # Detect what files changed to skip expensive jobs for docs-only changes
  detect-changes:
    name: Detect Changes
    runs-on: self-hosted
    permissions:
      contents: read
    outputs:
      code: ${{ steps.filter.outputs.code }}
      docs: ${{ steps.filter.outputs.docs }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need history to compare

      - name: Check changed files
        id: filter
        run: |
          # Determine base reference for comparison
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF="origin/${{ github.base_ref }}"
          else
            BASE_REF="${{ github.event.before }}"
          fi

          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only $BASE_REF...${{ github.sha }} 2>/dev/null || echo "")

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Check if any code files changed (Go, proto, configs, workflows)
          if echo "$CHANGED_FILES" | grep -qE '\.(go|proto|mod|sum)$|^(cmd|internal|pkg|deploy)/|^\.github/workflows/'; then
            echo "code=true" >> $GITHUB_OUTPUT
            echo "Code files changed: YES"
          else
            echo "code=false" >> $GITHUB_OUTPUT
            echo "Code files changed: NO"
          fi

          # Check if any docs changed
          if echo "$CHANGED_FILES" | grep -qE '\.(md|txt)$|^docs/'; then
            echo "docs=true" >> $GITHUB_OUTPUT
            echo "Docs files changed: YES"
          else
            echo "docs=false" >> $GITHUB_OUTPUT
            echo "Docs files changed: NO"
          fi

  # Test on multiple Go versions
  test:
    name: Test (Go ${{ matrix.go-version }})
    runs-on: self-hosted
    needs: detect-changes
    # Skip if only docs changed
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read
      actions: read
    strategy:
      matrix:
        go-version: ['1.25']

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Go installation
        run: |
          go version
          echo "GOPATH: $GOPATH"
          echo "Using pre-installed Go from runner image"

      - name: Clean Go cache
        run: |
          # Clean build and module cache to avoid version mismatch errors
          go clean -cache -modcache -testcache
          echo "Go cache cleared"

      - name: Install dependencies
        run: |
          # protoc and protoc-gen-* already installed in self-hosted runner
          echo "Using pre-installed protoc $(protoc --version)"

      - name: Generate protobuf code
        run: |
          protoc --go_out=. --go-grpc_out=. \
            --go_opt=paths=source_relative \
            --go-grpc_opt=paths=source_relative \
            pkg/proto/agent/v1/agent.proto

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Build
        run: go build -v ./...

      - name: Run tests
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  # Build test for multiple platforms
  build:
    name: Build (${{ matrix.os }}/${{ matrix.arch }})
    runs-on: self-hosted
    needs: detect-changes
    # Skip if only docs changed
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read
      actions: write  # For artifact upload
    strategy:
      matrix:
        os: [linux, freebsd]
        arch: [amd64, arm64]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Go installation
        run: go version

      - name: Clean Go cache
        run: |
          go clean -cache -modcache -testcache
          echo "Go cache cleared"

      - name: Generate protobuf
        run: |
          protoc --go_out=. --go-grpc_out=. \
            --go_opt=paths=source_relative \
            --go-grpc_opt=paths=source_relative \
            pkg/proto/agent/v1/agent.proto

      - name: Build
        env:
          GOOS: ${{ matrix.os }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: 0
        run: |
          OUTPUT="ocserv-agent-${{ matrix.os }}-${{ matrix.arch }}"
          if [ "${{ matrix.os }}" = "windows" ]; then
            OUTPUT="${OUTPUT}.exe"
          fi
          go build -trimpath -ldflags="-s -w" -o "$OUTPUT" ./cmd/agent

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-${{ matrix.arch }}
          path: ocserv-agent-*
          if-no-files-found: error

  # Generate SBOM for built artifacts
  sbom:
    name: Generate SBOM
    runs-on: self-hosted
    needs: [detect-changes, build]
    # Skip if only docs changed (build will be skipped too)
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read
      actions: read  # For artifact download

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          path: artifacts/

      - name: Generate SBOM for repository
        run: |
          # Generate SBOM for source code and dependencies
          syft scan dir:. \
            --output cyclonedx-json=sbom-repo.json \
            --output spdx-json=sbom-repo-spdx.json

      - name: Generate SBOMs for binaries
        run: |
          # Generate SBOM for each built binary
          for binary in artifacts/binary-*/*; do
            if [ -f "$binary" ]; then
              base=$(basename "$binary")
              echo "Generating SBOM for $base..."
              syft scan "file:$binary" \
                --output cyclonedx-json="sbom-${base}.json"
            fi
          done

      - name: Upload SBOMs
        uses: actions/upload-artifact@v4
        with:
          name: sbom-files
          path: sbom-*.json
          if-no-files-found: error

  # Scan built binaries for vulnerabilities
  grype-scan:
    name: Post-Build Vulnerability Scan
    runs-on: self-hosted
    needs: [detect-changes, build, sbom]
    # Skip if only docs changed
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read
      actions: read  # For artifact download
      security-events: write  # For SARIF upload

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v6
        with:
          path: artifacts/

      - name: Scan binaries with Grype
        run: |
          # Scan each binary for vulnerabilities
          mkdir -p sarif-results
          SARIF_COUNT=0
          for binary in artifacts/binary-*/*; do
            if [ -f "$binary" ]; then
              base=$(basename "$binary")
              echo "Scanning $base with Grype..."

              # Run grype and check if SARIF was created
              grype "file:$binary" \
                --output sarif \
                --file "sarif-results/grype-${base}.sarif" 2>&1 || true

              # Check if SARIF file was actually created
              if [ -f "sarif-results/grype-${base}.sarif" ]; then
                SARIF_COUNT=$((SARIF_COUNT + 1))
                echo "✓ Generated grype-${base}.sarif"
              else
                echo "ℹ No SARIF generated for $base (likely no vulnerabilities found)"
              fi
            fi
          done

          echo "Total SARIF files generated: $SARIF_COUNT"
          echo "SARIF_COUNT=$SARIF_COUNT" >> $GITHUB_ENV

          # List generated files for debugging
          if [ $SARIF_COUNT -gt 0 ]; then
            echo "Generated SARIF files:"
            ls -la sarif-results/
          else
            echo "No SARIF files generated"
          fi

      - name: Merge SARIF files
        if: always() && env.SARIF_COUNT != '0'
        run: |
          # Merge all SARIF files into one
          # The upload-sarif action requires a single SARIF file per upload
          echo "Merging $(ls -1 sarif-results/*.sarif | wc -l) SARIF files..."

          # Create merged SARIF with combined runs from all files
          first=true
          for sarif_file in sarif-results/*.sarif; do
            if [ -f "$sarif_file" ]; then
              if [ "$first" = true ]; then
                # Use first file as base
                cp "$sarif_file" merged-grype.sarif
                first=false
              else
                # Merge subsequent files' runs into the base file
                jq -s '.[0].runs += .[1].runs | .[0]' merged-grype.sarif "$sarif_file" > temp-merged.sarif
                mv temp-merged.sarif merged-grype.sarif
              fi
            fi
          done

          echo "✓ Merged SARIF file created: merged-grype.sarif"
          jq '.runs | length' merged-grype.sarif

      - name: Upload Grype results
        # Allow failure due to GitHub limitation: cannot upload multiple runs per category
        # See: https://github.blog/changelog/2025-07-21-code-scanning-will-stop-combining-multiple-sarif-runs-uploaded-in-the-same-sarif-file/
        # For statically-linked Go binaries, Grype typically finds no vulnerabilities anyway
        continue-on-error: true
        if: always() && env.SARIF_COUNT != '0'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: merged-grype.sarif
          category: grype-scan

  # Integration tests with containers
  integration:
    name: Integration Tests
    runs-on: self-hosted
    needs: [detect-changes, build, sbom, grype-scan]
    # Skip if only docs changed (build will be skipped too)
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read
      actions: read  # For artifact download

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Go installation
        run: go version

      - name: Clean Go cache
        run: |
          go clean -cache -modcache -testcache
          echo "Go cache cleared"

      - name: Generate protobuf
        run: |
          protoc --go_out=. --go-grpc_out=. \
            --go_opt=paths=source_relative \
            --go-grpc_opt=paths=source_relative \
            pkg/proto/agent/v1/agent.proto

      - name: Run integration tests
        run: |
          # TODO: Add integration tests when available
          echo "Integration tests not yet implemented"
          # go test -v -tags=integration ./test/integration/...

  # Check for formatting and vet issues
  # Always run (fast and catches issues early)
  checks:
    name: Code Quality Checks
    runs-on: self-hosted
    needs: detect-changes
    # Skip if only docs changed
    if: needs.detect-changes.outputs.code == 'true' || github.event_name == 'push'
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Go installation
        run: go version

      - name: Clean Go cache
        run: |
          go clean -cache -modcache -testcache
          echo "Go cache cleared"

      - name: Generate protobuf
        run: |
          protoc --go_out=. --go-grpc_out=. \
            --go_opt=paths=source_relative \
            --go-grpc_opt=paths=source_relative \
            pkg/proto/agent/v1/agent.proto

      - name: Check formatting
        run: |
          if [ -n "$(gofmt -s -l . | grep -v '^vendor/' | grep -v '.pb.go$')" ]; then
            echo "Go code is not formatted:"
            gofmt -s -d . | grep -v '^vendor/' | grep -v '.pb.go$'
            exit 1
          fi

      - name: Run go vet
        run: go vet ./...

      - name: Run staticcheck
        run: |
          # Run staticcheck installed in runner
          staticcheck -checks=all,-ST1000,-ST1003 ./...

      - name: Check go mod tidy
        run: |
          go mod tidy
          git diff --exit-code go.mod go.sum

      - name: Check for common Go mistakes
        run: |
          # errcheck - check for unchecked errors
          if command -v errcheck &> /dev/null; then
            errcheck ./...
          else
            echo "errcheck not installed, skipping"
          fi
        continue-on-error: true

      - name: Check for ineffectual assignments
        run: |
          # ineffassign - detect ineffectual assignments
          if command -v ineffassign &> /dev/null; then
            ineffassign ./...
          else
            echo "ineffassign not installed, skipping"
          fi
        continue-on-error: true

  # Summary job that always succeeds (for required status checks)
  # This ensures docs-only PRs can be merged even when heavy jobs are skipped
  ci-success:
    name: CI Success
    runs-on: self-hosted
    needs: [detect-changes, test, build, sbom, grype-scan, integration, checks]
    if: always()  # Run even if jobs were skipped
    steps:
      - name: Check job results
        run: |
          # If only docs changed, all jobs will be skipped - that's OK
          if [ "${{ needs.detect-changes.outputs.code }}" = "false" ]; then
            echo "✅ Docs-only changes - heavy jobs skipped (expected)"
            exit 0
          fi

          # If code changed, check that all jobs succeeded
          if [ "${{ needs.test.result }}" = "success" ] && \
             [ "${{ needs.build.result }}" = "success" ] && \
             [ "${{ needs.sbom.result }}" = "success" ] && \
             [ "${{ needs.grype-scan.result }}" = "success" ] && \
             [ "${{ needs.integration.result }}" = "success" ] && \
             [ "${{ needs.checks.result }}" = "success" ]; then
            echo "✅ All CI jobs passed"
            exit 0
          fi

          # Some job failed
          echo "❌ Some CI jobs failed"
          echo "test: ${{ needs.test.result }}"
          echo "build: ${{ needs.build.result }}"
          echo "sbom: ${{ needs.sbom.result }}"
          echo "grype-scan: ${{ needs.grype-scan.result }}"
          echo "integration: ${{ needs.integration.result }}"
          echo "checks: ${{ needs.checks.result }}"
          exit 1
